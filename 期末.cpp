```c++
#include<stdio.h>
int main(){
      printf("Hello,World!");
  return 0;
}
```

成绩
描述

牛牛最近学习了C++入门课程，这门课程的总成绩计算方法是：
总成绩=作业成绩 x20%+ 小测成绩×30%+ 期末考试成绩 ×50%
牛牛想知道，这门课程自己最终能得到多少分。
数据范围：
对于 30% 的数据， A=B=0。
对于另外 30% 的数据， A=B=100 。
对于 100% 的数据， 0≤A,B,C≤100 且 A,B,C 都是 10 的整数倍。


输入

三个非负整数 A,B,C分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 100分


输出


```c++
#include <stdio.h>
int main(){
  int A,B,C;
  scanf("%d %d %d",&A,&B,&C);
  int sum;
  sum = A * 0.2 + B * 0.3 + C * 0.5;
  printf("%d",sum);
}
```

买铅笔
描述

P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 3种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P老师决定只买 同一种包装 的铅笔。
商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过n支铅笔才够给小朋友们发礼物。现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少n支铅笔最少需要花费多少钱。


输入

输入的第一行包含一个正整数n，表示需要的铅笔数量。
接下来三行，每行用两个正整数描述一种包装的铅笔：其中第一个整数表示这种 包装内铅笔的数量，第二个整数表示这种包装的价格。
保证所有的7个数都是不超过10000的正整数。


输出

输出一行一个整数，表示P老师最少需要花费的钱。

```c++
#include <stdio.h>
using namespace std;
int n,A,B,C,minx=0x7fffffff;//赋最大值
int main(){
    scanf("%d",&n);
    for(int i = 1; i<=3;i++){
        scanf("%d %d",&A,&B);
        C = (n/A+(n%A!=0)) * B;//布尔运算为真，即不能整除就多买一包
        if(C<minx) minx = C;
    }
    printf("%d\n",minx);
    return 0;
}
```

你的飞碟在这儿
描述

众所周知，在每一个彗星后都有一只UFO。这些UFO时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢 ）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的UFO带走。小组名和彗星名都以下列方式转换成一个数字：     最终的数字就是名字中所有字母的积   ，其中“A”是1，“Z”是26。例如，“USACO”小组就是21191315=17955。如果小组的数字 mod 47等于彗星的数字mod 47,你就得告诉这个小组需要准备好被带走！（记住“a mod b”是a除以b的余数；34 mod 10等于4）
写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出“GO”，否则输出“STAY”。小组名和彗星名均是没有空格或标点的一串大写字母（不超过6个字母）。


输入

第1行：一个长度为1到6的大写字母串，表示彗星的名字。
第2行：一个长度为1到6的大写字母串，表示队伍的名字。


输出

-64

```c++
#include <stdio.h>
#include <string.h>
int main(){
    char A[6],B[6];
    int a = 1,b = 1;
    for(int i=0;i<=6;i++){
        scanf("%s",A[i]);
        a *= A[i] - 64;
    }
    for(int i=0;i<=6;i++){
        scanf("%s",B[i]);
        b *= B[i] - 64;
    }
    
    if(a%47==b%47){
        printf("GO");
    }
	else {
		printf("STAY");
	}
	return 0;
}

	
#include <iostream>
#include <cstring>
using namespace std ;

string a, b ;
int ans = 1, num = 1 ;  //这里要注意起始值必须为1，要是0的话所有的数乘出来都是0了

int main()
{
    cin >> a >> b ; // 输入
    for( int i = 0 ; i < a.length() ; i ++ )
        ans *= a[i] - '@' ;
    // @的编号为64 ，A的编号65-@的编号64不就是所对应的英语字母序号了嘛...
    for( int i = 0 ; i < b.length() ; i ++ )
        num *= b[i] - '@' ;
    // 同上
    ans %= 47, num %= 47 ;  // 根据题意，mod 47
    if( ans == num )
        cout << ""GO"" ;
    else
        cout << ""STAY"" ; //输出
    return 0 ; 
}
"
图像相似度
描述

给出两幅相同大小的黑白图像（用0-1矩阵）表示，求它们的相似度。
说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。


输入

第一行包含两个整数m和n，表示图像的行数和列数，中间用单个空格隔开。1 <= m <= 100, 1 <= n <= 100。 之后m行，每行n个整数0或1，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 之后m行，每行n个整数0或1，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。


输出

一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位


输入样例 1 

3 3
1 0 1
0 0 1
1 1 0
1 1 0
0 0 1
0 0 1
输出样例 1

44.44


#include <stdio.h>
#define N 100
int a[N][N], b[N][N];
int main(void)
{
    int m, n, i, j;
    scanf("%d%d", &m, &n);
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            scanf("%d", &a[i][j]);
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            scanf("%d", &b[i][j]);
    int count = 0;
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            if(a[i][j] == b[i][j])
                count++;
    printf("%.2f\n", (float)100 * count / (m * n));
    return 0;
}